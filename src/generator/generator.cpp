#include <fstream>
#include <iostream>
#include <algorithm>
#include <string_view>

#include <vypcomp/generator/generator.h>
#include <vypcomp/ir/instructions.h>

using namespace vypcomp;
using namespace std::string_literals;

constexpr std::string_view VYPLANG_PREFIX = "vl_";

vypcomp::Generator::Generator(std::string out_filename, bool verbose)
    : verbose(verbose) 
{
    _main_out = std::make_unique<std::ofstream>(out_filename);
}

vypcomp::Generator::Generator(std::unique_ptr<std::ostream> out, bool verbose)
    : _main_out(std::move(out)), verbose(verbose)
{
}

const vypcomp::Generator::OutputStream& vypcomp::Generator::get_output() const
{
    return *_main_out.get();
}

void vypcomp::Generator::generate(const vypcomp::SymbolTable& symbol_table)
{
    OutputStream& out = *_main_out;
    out << "#! /bin/vypint\n# VYPcode: 1.0\n# Generated by: xmicka11 & xkubov06\n";
    // program prolog
    // generates chunks representing vtables and puts them at the stack base
    generate_vtables(symbol_table, out);
    // proper call to main makes the order of functions meaningless
    out << "CALL [$SP] " << VYPLANG_PREFIX << "main" << "\n" << "JUMP ENDOFPROGRAM" << std::endl;

    for (auto [_, symbol] : symbol_table.data()) {
        if (std::holds_alternative<ir::Function::Ptr>(symbol))
        {
            auto function = std::get<ir::Function::Ptr>(symbol);
            if (is_builtin_func(function->name()))
            {
                // these are generated by `generate_builtin_functions`
                continue;
            }
            else
            {
                generate_function(function, std::string(VYPLANG_PREFIX) + function->name(), out);
            }
        }
        else if (std::holds_alternative<ir::Class::Ptr>(symbol))
        {
            auto class_symbol = std::get<ir::Class::Ptr>(symbol);
            generate_class(class_symbol, out);
            //std::cerr << "class generation is not supported yet, skipping " << class_symbol->name() << std::endl;
        }
        else
        {
            throw std::runtime_error("unexpected symbol on top level symbol table");
        }
    }
    generate_builtin_functions(out);
    // program epilog
    out << "LABEL ENDOFPROGRAM";
}

void vypcomp::Generator::generate_vtables(const vypcomp::SymbolTable& symbol_table, OutputStream& out)
{
    // vtables reside at the stack base, they will be referenced by absolute addresses in their particular instances
    std::size_t address_counter = 0;
    for (auto [_, symbol] : symbol_table.data()) {
        if (std::holds_alternative<ir::Class::Ptr>(symbol))
        {
            auto class_symbol = std::get<ir::Class::Ptr>(symbol);
            std::stringstream class_vtable_init;
            //generate_vtable(class_symbol, class_vtable_init);
            VtableMapping class_vtable;
            VtableMapping super_vtable;
            MethodVector vtable_indices; 
            VtableIndexLookupPtr method_id_mapping = std::make_shared<VtableIndexLookup>();
            class_method_vtable_mapping[class_symbol->name()] = method_id_mapping; // lookup used to do Class -> Method -> vtable offset lookup
            std::size_t index = 0;
            for (auto i = class_symbol->methods_begin(), end = class_symbol->methods_end(); i != end; i += 1)
            {
                auto method = *i;
                class_vtable[method->name()] = generate_method_label(method);
                auto [iter, inserted] = super_vtable.insert(std::make_pair(method->name(), generate_method_label(method))); // super table holds the first method of the hierarchy
                if (inserted)
                {
                    (*method_id_mapping)[method->name()] = vtable_indices.size();
                    vtable_indices.push_back(method->name());
                }
            }
            const auto vtable_size = vtable_indices.size();
            class_vtable_init << "CREATE $0, " << vtable_size;
            if (verbose)
                class_vtable_init << " # vtable for " << class_symbol->name() << std::endl;
            else
                class_vtable_init << std::endl;
            for (auto entry_id = 0u; entry_id < vtable_size; entry_id++)
            {
                auto method_at_index = vtable_indices[entry_id];
                auto method_label = class_vtable[method_at_index];
                class_vtable_init << "SETWORD $0, " << entry_id << ", \"" << method_label << "\"\n";
            }

            out << "ADDI $SP, $SP, 1";
            if (verbose)
                out << " # reserve space for vtable" << std::endl;
            else
                out << std::endl;
            // create the chunk and set its values
            out << class_vtable_init.str();
            // save the chunk id on stack
            out << "SET [" << address_counter << "], $0\n" << std::endl;
            class_vtable_addr_mapping[class_symbol->name()] = address_counter;
            address_counter++;
        }
    }
}

std::string vypcomp::Generator::generate_method_label(const ir::Function::Ptr& method)
{
    return VYPLANG_PREFIX.data() + method->argTypes()[0].get<ir::Datatype::ClassName>() + "_"s + method->name();
}

void vypcomp::Generator::generate_class(vypcomp::ir::Class::Ptr input, OutputStream& out)
{
    generate_constructor(input, out);

    for (auto& method_list : { input->publicMethods(), input->protectedMethods(), input->privateMethods() })
    {
        for (auto& method : method_list)
        {
            if (input->name() == "Object" && method->name() == "toString")
            {
                out << "LABEL " << VYPLANG_PREFIX << input->name() << "_" << method->name() << std::endl;
                out << "SET $1, [$SP-1]\n";
                out << "INT2STRING $0, $1\n";
                out << "SET $1, [$SP]\n";
                out << "SUBI $SP, $SP, 2\n"; // clean up return address space + this arg
                out << "RETURN $1\n" << std::endl;
            }
            else if (input->name() == "Object" && method->name() == "getClass")
            {
                out << "LABEL " << VYPLANG_PREFIX << input->name() << "_" << method->name() << std::endl;
                out << "SET $1, [$SP-1]\n"; // $1 now has object chunk id
                out << "GETWORD $0, $1, 1\n"; // type name string has offset 1
                out << "SET $1, [$SP]\n";
                out << "SUBI $SP, $SP, 2\n"; // clean up return address space + this arg
                out << "RETURN $1\n" << std::endl;
            }
            else
            {
                generate_function(method, std::string(VYPLANG_PREFIX) + input->name() + "_"s + method->name(), out);
            }
        }
    }
}

void vypcomp::Generator::generate_constructor(vypcomp::ir::Class::Ptr input, OutputStream& out)
{
    AllocaVector args{};
    AllocaVector local_vars{};
    auto object_size = get_object_size(input);
    out << "LABEL " << VYPLANG_PREFIX << input->name() << "_constructor\n";
    // reserver space for object ref
    out << "ADDI $SP, $SP, 1\n";
    // create chunk
    out << "CREATE $0, " << object_size << "\n";
    out << "SET [$SP], $0\n";
    // invoke all parent constructors here
    generate_constructor_chain_invocation(input, out);
    
    auto vtable_address = class_vtable_addr_mapping[input->name()];
    out << "SETWORD [$SP], 0, [" << vtable_address << "]";
    if (verbose)
        out << " # set vtable pointing to " << input->name() << " vtable" << std::endl;
    else
        out << std::endl;
    // set classname for dynamic casts
    out << "SETWORD [$SP], 1, \"" << input->name() << "\"\n";

    out << "SET $0, [$SP]\n";
    out << "SUBI $SP, $SP, 1\n"; // clean up 1 local var
    out << "SET $1, [$SP]\n";
    out << "SUBI $SP, $SP, 1\n"; // clean up return address space
    out << "RETURN $1\n" << std::endl;

    // generate code for user-defined constructor if it exists
    if (input->constructor())
        generate_function(input->constructor(), VYPLANG_PREFIX.data() + input->name() + "_constructor_body", out);
}

void vypcomp::Generator::generate_constructor_chain_invocation(vypcomp::ir::Class::Ptr input, OutputStream& out)
{
    if (!input) return;
    auto parent = input->getBase();
    // first call parent constructor
    generate_constructor_chain_invocation(parent, out);
    // then initialize values of this class
    for (auto& implicit_instr : input->implicit())
    {
        auto implicit_assignment = dynamic_cast<ir::Assignment*>(implicit_instr.get());
        if (!implicit_assignment) throw std::runtime_error("Implicit instruction was not an assignment:\n" + implicit_instr->str(""));
        auto destination = implicit_assignment->getAlloca();
        auto value_expr = implicit_assignment->getExpr();
        auto attribute_offset = get_object_attribute_offset(input, destination->name());
        if (verbose)
            out << "# initialize value of " << destination->name() << std::endl;
        auto om = OffsetMap();
        auto tmp = TempVarMap();
        generate_expression(value_expr, "$0", om, tmp, out);
        out << "SETWORD [$SP], " << attribute_offset << ", $0" << std::endl;
    }
    // then jump into user-defined constructor body of current class
    if (input->constructor())
    {
        out << "ADDI $SP, $SP, 2\n";
        out << "SET [$SP-1], [$SP-2]\n"; // push local variable containing new chunk id as an argument
        out << "CALL [$SP], " << VYPLANG_PREFIX << input->name() << "_constructor_body" << std::endl;
    }
}

std::size_t vypcomp::Generator::get_object_size(vypcomp::ir::Class::Ptr input)
{
    std::size_t obj_size = 0;
    auto parent = input->getBase();
    if (parent)
    {
        auto parent_size = get_object_size(parent);
        obj_size += parent_size;
    }
    else
    {
        obj_size += 2;
    }
    obj_size += input->getAttributeCount();
    return obj_size;
}

void vypcomp::Generator::generate_function(vypcomp::ir::Function::Ptr input, std::string label_name, OutputStream& out)
{
    if (!input) return;
    auto first_block = input->first();
    out << "LABEL " << label_name << std::endl;
    // TempVarMap holds destination for each expression result 
    // (currently each expression producing new value gets separate stack location aka "local variable" with lifetime of the whole function execution)
    TempVarMap temporary_variables_mapping; 
    // local_variables consists of all possible local variables with variable in sub-scopes as well
    auto local_variables = get_alloca_instructions(first_block->first(), temporary_variables_mapping);
    const auto& args = input->args();
    arg_count = args.size();
    variable_count = local_variables.size();
    
    generate_function_body(input, out, args, local_variables, temporary_variables_mapping);
}

void vypcomp::Generator::generate_constructor_body(vypcomp::ir::Function::Ptr input, std::string label_name, OutputStream& out) // TODO: OBSOLETE
{
    if (!input) return;
    auto first_block = input->first();
    out << "LABEL " << label_name << std::endl;
    // TempVarMap holds destination for each expression result 
    // (currently each expression producing new value gets separate stack location aka "local variable" with lifetime of the whole function execution)
    TempVarMap temporary_variables_mapping;
    // local_variables consists of all possible local variables with variable in sub-scopes as well
    auto local_variables = get_alloca_instructions(first_block->first(), temporary_variables_mapping);
    const auto& args = input->args();
    arg_count = args.size();
    variable_count = local_variables.size();

    generate_function_body(input, out, args, local_variables, temporary_variables_mapping);
}

void vypcomp::Generator::generate_function_body(vypcomp::ir::Function::Ptr input, OutputStream& out, const AllocaVector& args, const AllocaVector& local_variables, TempVarMap& temporary_variables_mapping)
{
    OffsetMap variable_offsets{};
    if (arg_count != 0)
    {
        // assign $SP offsets of arguments
        for (std::size_t i = 0; i < arg_count; i++)
        {
            auto& alloca_instr = args[i];
            std::int64_t offset = arg_count - i; // first arg has lowest stack position, last arg is $SP-1
            variable_offsets[alloca_instr.get()] = offset;
        }
    }
    if (variable_count != 0)
    {
        // if there are any variables in the possible instruction stream, reserve stack space for them
        out << "ADDI $SP, $SP, " << variable_count << std::endl;
        // shift the offsets of function arguments
        std::for_each(variable_offsets.begin(), variable_offsets.end(), [this](auto& ptr_offset_pair) { ptr_offset_pair.second += variable_count;  });
        // insert $SP offsets of local variables
        for (std::size_t i = 0; i < variable_count; i++)
        {
            auto& alloca_instr = local_variables[i];
            std::int64_t offset = variable_count - i - 1; // last variable is [$SP]
            variable_offsets[alloca_instr.get()] = offset;
        }
    }
    if (verbose)
    {
        // dump offsets of all local symbols into code
        for (auto& alloca_instr : args)
        {
            auto offset = variable_offsets[alloca_instr.get()];
            out << "# [$SP-" << offset << "] " << alloca_instr->name() << std::endl;
        }
        for (auto& alloca_instr : local_variables)
        {
            auto offset = variable_offsets[alloca_instr.get()];
            out << "# [$SP-" << offset << "] " << alloca_instr->name() << std::endl;
        }
    }

    generate_block(input->first(), variable_offsets, temporary_variables_mapping, out);

    if (!is_return(input->first()->last()))
    {
        out << "SET $0, 0" << std::endl;
        generate_return(out);
    }
}

void vypcomp::Generator::generate_block(vypcomp::ir::BasicBlock::Ptr in_block, OffsetMap& variable_offsets, TempVarMap& temporary_variables_mapping, OutputStream& out)
{
    for (auto instruction = in_block->first(); instruction != nullptr; instruction = instruction->next())
    {
        generate_instruction(instruction, variable_offsets, temporary_variables_mapping, out);
    }
}

void vypcomp::Generator::generate_return(OutputStream& out)
{
    //  high address
    // |  ...    | < SP after prolog
    // |  loc2   |
    // |  loc1   |
    // | return  | < SP at entry
    // |  arg3   |
    // |  arg2   |
    // |  arg1   |
    // |  ...    |
    //  low address
    // stack layout
    // generate implicit 0 return
    if (variable_count != 0)
    {
        // reclaim stack of local variables
        out << "SUBI $SP, $SP, " << variable_count;
        if (verbose)
            out << " # [$SP] is now return address\n";
        else
            out << "\n";
    }
    // reclaim stack of arguments, move by at least one (return address)
    out << "SET $1, [$SP]" << "\n";
    out << "SUBI $SP, $SP, " << arg_count+1 << "\n";
    out << "RETURN $1\n" << std::endl;
}

void vypcomp::Generator::generate_instruction(vypcomp::ir::Instruction::Ptr input, OffsetMap& variable_offsets, TempVarMap& temporary_variables_mapping, OutputStream& out)
{
    if (auto instr = dynamic_cast<ir::AllocaInstruction*>(input.get()))
    {
        return; // these are handled elsewhere
    }
    else if (auto instr = dynamic_cast<ir::Assignment*>(input.get()))
    {
        auto destination = instr->getAlloca();
        auto expr = instr->getExpr();
        if (!destination) 
        {
            // statement level function call that discards the result
            generate_expression(expr, "", variable_offsets, temporary_variables_mapping, out);
        }
        else
        {
            auto variable_offset_iter = variable_offsets.find(destination.get());
            if (variable_offset_iter == variable_offsets.end()) throw std::runtime_error("Assignment destination was not found while generating assignment");
            auto& [_, variable_offset] = *variable_offset_iter;
            auto result_register = std::string("$0");
            generate_expression(expr, result_register, variable_offsets, temporary_variables_mapping, out);
            out << "SET [$SP-" << variable_offset << "], " << result_register << std::endl;
        }
    }
    else if (auto instr = dynamic_cast<ir::ObjectAssignment*>(input.get()))
    {
        auto destination = instr->getTarget();
        auto value_expr = instr->getExpr();
        ir::ObjectAttributeExpression* target_expression = dynamic_cast<ir::ObjectAttributeExpression*>(destination.get());
        if (!target_expression)
        {
            throw std::runtime_error("Target of object assignment is not an object attribute, but instead: " + destination->to_string());
        }
        auto object_alloca = target_expression->getObject();
        auto object_stack_offset = find_offset(object_alloca.get(), variable_offsets);
        if (!object_stack_offset) throw std::runtime_error("Target of object attribute assignment was not found: " + object_alloca->name());
        auto attribute_name = target_expression->getAttribute()->name();
        auto attribute_chunk_offset = get_object_attribute_offset(target_expression->getClass(), attribute_name);
        generate_expression(value_expr, "$1", variable_offsets, temporary_variables_mapping, out);
        out << "SETWORD [$SP-" << object_stack_offset.value() << "], " << attribute_chunk_offset << ", " << "$1" << std::endl;
    }
    else if (auto instr = dynamic_cast<ir::Return*>(input.get()))
    {
        if (!instr->isVoid())
        {
            auto expr = instr->getExpr();
            generate_expression(expr, "$0", variable_offsets, temporary_variables_mapping, out);
        }
        generate_return(out);
    }
    else if (auto instr = dynamic_cast<ir::BranchInstruction*>(input.get()))
    {
        static std::uint64_t if_label_index = 0;
        auto str_label_index = std::to_string(if_label_index++);
        auto expr = instr->getExpr();
        auto if_block = instr->getIf();
        auto else_block = instr->getElse();
        auto label_if = "if_branch_"s + str_label_index;
        auto label_else = "else_branch_"s + str_label_index;
        auto label_end = "endif_label_"s + str_label_index;
        std::stringstream if_instruction_stream, else_instruction_stream;

        generate_block(if_block, variable_offsets, temporary_variables_mapping, if_instruction_stream);
        generate_block(else_block, variable_offsets, temporary_variables_mapping, else_instruction_stream);

        generate_expression(expr, "$0", variable_offsets, temporary_variables_mapping, out);
        out << "JUMPZ " << label_else << ", $0\n";

        out << "LABEL " << label_if << "\n";
        if (if_instruction_stream.rdbuf()->in_avail())
            out << if_instruction_stream.rdbuf();
        out << "JUMP " << label_end << "\n";

        out << "LABEL " << label_else << "\n";
        if (else_instruction_stream.rdbuf()->in_avail())
            out << else_instruction_stream.rdbuf();
        out << "JUMP " << label_end << "\n";

        out << "LABEL " << label_end << std::endl;
    }
    else if (auto instr = dynamic_cast<ir::LoopInstruction*>(input.get()))
    {
        static std::uint64_t while_label = 0;
        auto str_while_label = std::to_string(while_label++);
        auto expr = instr->getExpr();
        auto body_block = instr->getBody();
        auto condition_label = "while_cond_"s + str_while_label;
        auto end_label = "while_end_"s + str_while_label;

        std::stringstream body_instruction_stream;
        generate_block(body_block, variable_offsets, temporary_variables_mapping, body_instruction_stream);

        out << "LABEL " << condition_label << "\n";
        generate_expression(expr, "$0", variable_offsets, temporary_variables_mapping, out);
        out << "JUMPZ " << end_label << ", $0\n";
        if (body_instruction_stream.rdbuf()->in_avail())
            out << body_instruction_stream.rdbuf();
        out << "JUMP " << condition_label << "\n";
        out << "LABEL " << end_label << std::endl;
    }
    else
    {
        std::cerr << "skipping past instruction:\n" << input->str("") << std::endl;
        //throw std::runtime_error("Generator encountered unsupported IR instruction type.");
    }
}

void vypcomp::Generator::generate_expression(ir::Expression::ValueType input, DestinationName destination, OffsetMap& variable_offsets, TempVarMap& temporary_variables_mapping, OutputStream& out)
{   
    if (auto lit_expr = dynamic_cast<ir::LiteralExpression*>(input.get()))
    {
        auto lit_value = lit_expr->getValue();
        if (destination.size() == 0) throw std::runtime_error("Can't assign literal expression to null.");
        out << "SET " << destination << ", " << lit_value.vypcode_representation() << std::endl;
    }
    else if (auto constr_expr = dynamic_cast<ir::ConstructorExpression*>(input.get()))
    {
        // reserve stack space
        out << "ADDI $SP, $SP, 1";
        if (verbose)
            out << " # reserved stack for return address" << std::endl;
        else
            out << std::endl;
        // shift local variable offsets by the amount stack increased
        std::for_each(variable_offsets.begin(), variable_offsets.end(), [](auto& ptr_offset_pair) { ptr_offset_pair.second += 1ll;  });
        out << "CALL [$SP], " << VYPLANG_PREFIX << constr_expr->getFunctionName() << "_constructor\n";
        if (destination.size() && destination != "$0")
            out << "SET " << destination << ", $0" << std::endl;
        // shift local variable offsets back, since callee cleaned up the stack
        std::for_each(variable_offsets.begin(), variable_offsets.end(), [](auto& ptr_offset_pair) { ptr_offset_pair.second -= 1ll;  });

    }
    else if (auto method_exp = dynamic_cast<ir::MethodExpression*>(input.get()))
    {
        auto function_args = method_exp->getArgs();
        const auto args_count = function_args.size();
        auto context_object = method_exp->getContextObj();
        // reserve stack space
        out << "ADDI $SP, $SP, " << args_count + 1; // at least one for return address, last arg is $SP-1
        if (verbose)
            out << " # reserved stack for " << args_count << " function parameters + return address" << std::endl;
        else
            out << std::endl;
        // shift local variable offsets by the amount stack increased
        std::for_each(variable_offsets.begin(), variable_offsets.end(), [args_count](auto& ptr_offset_pair) { ptr_offset_pair.second += args_count + 1ll;  });
        // calculate each argument expression and store it on proper stack position
        for (std::size_t i = 0; i < args_count; i++)
        {
            const ir::Expression::ValueType& argument = function_args[i];
            generate_expression(argument, "$0", variable_offsets, temporary_variables_mapping, out);
            std::int64_t offset = args_count - i; // first argument has lowest stack address, last is $SP-1
            out << "SET " << "[$SP-" << offset << "], $0" << std::endl;
            if (i == 0)
            {
                if (auto superexp = dynamic_cast<ir::SuperExpression*>(context_object.get()))
                {
                    // super suppresses lookup of method in vtable and hardcodes the first implementation of such method
                    continue;
                }
                else
                {
                    // first argument is the object being having the method called
                    out << "GETWORD $1, $0, 0\n"; // get vtable chunk id
                    auto method_offset_map = class_method_vtable_mapping[context_object->type().get<ir::Datatype::ClassName>()];
                    auto method_offset = (*method_offset_map)[method_exp->getFunction()->name()];
                    out << "GETWORD $2, $1, " << method_offset << "\n"; // $2 now should now have chunk id of chunk with label name
                    // store the chunk id of label in the to-be return address
                    out << "SET [$SP], $2" << std::endl;
                }
            }
        }
        // jump into subroutine
        if (auto superexp = dynamic_cast<ir::SuperExpression*>(context_object.get()))
        {
            auto child_class = superexp->getClass();
            auto parent_class = child_class->getBase();
            // find the first occurence of the method
            auto original_method = parent_class->getMethod(method_exp->getFunction()->name());
            std::string label_name = generate_method_label(original_method);
            // in case it was accessed through super object, ignore vtables and get the first implementation
            out << "CALL [$SP], " << label_name << std::endl;
        }
        else
        {
            // [$SP] holds the chunk id of the label to be jumped to in case the jump resolution is vtable based
            out << "CALL [$SP], [$SP]" << std::endl;
        }

        // return value register is always $0
        if (destination.size() && destination != "$0")
            out << "SET " << destination << ", $0" << std::endl;
        // shift local variable offsets back, since callee cleaned up the stack
        std::for_each(variable_offsets.begin(), variable_offsets.end(), [args_count](auto& ptr_offset_pair) { ptr_offset_pair.second -= args_count + 1ll;  });
    }
    else if (auto func_expr = dynamic_cast<ir::FunctionExpression*>(input.get()))
    {
        std::string func_name = func_expr->getFunction()->name();

        auto function_args = func_expr->getArgs();
        const auto args_count = function_args.size();
        if (func_name == "print")
        {
            // each argument is a standalone call
            for (std::size_t i = 0; i < args_count; i++)
            {
                const ir::Expression::ValueType& argument = function_args[i];
                ir::Datatype argument_type = argument->type();
                // should be safe because primitive types are checked by parser
                ir::PrimitiveDatatype prim_type = argument_type.get<ir::PrimitiveDatatype>();
                generate_expression(argument, "$0", variable_offsets, temporary_variables_mapping, out);
                switch (prim_type)
                {
                case ir::PrimitiveDatatype::Int:
                    out << "WRITEI $0" << std::endl;
                    break;
                case ir::PrimitiveDatatype::String:
                    out << "WRITES $0" << std::endl;
                    break;
                case ir::PrimitiveDatatype::Float:
                    out << "WRITEF $0" << std::endl;
                    break;
                default:
                    throw std::runtime_error("Unexpected primitive type in print.");
                }
            }
        }
        else
        {
            // reserve stack space
            out << "ADDI $SP, $SP, " << args_count + 1; // at least one for return address, last arg is $SP-1
            if (verbose)
                out << " # reserved stack for " << args_count << " function parameters + return address" << std::endl;
            else
                out << std::endl;
            // shift local variable offsets by the amount stack increased
            std::for_each(variable_offsets.begin(), variable_offsets.end(), [args_count](auto& ptr_offset_pair) { ptr_offset_pair.second += args_count + 1ll;  });
            // calculate each argument expression and store it on proper stack position
            for (std::size_t i = 0; i < args_count; i++)
            {
                const ir::Expression::ValueType& argument = function_args[i];
                generate_expression(argument, "$0", variable_offsets, temporary_variables_mapping, out);
                std::int64_t offset = args_count - i; // first argument has lowest stack address, last is $SP-1
                out << "SET " << "[$SP-" << offset << "], $0" << std::endl;
            }
            // jump into subroutine
            out << "CALL [$SP], " << VYPLANG_PREFIX.data() + func_name << std::endl;
            // return value register is always $0
            if (destination.size() && destination != "$0")
                out << "SET " << destination << ", $0" << std::endl;
            // shift local variable offsets back, since callee cleaned up the stack
            std::for_each(variable_offsets.begin(), variable_offsets.end(), [args_count](auto& ptr_offset_pair) { ptr_offset_pair.second -= args_count + 1ll;  });
        }
    }
    else if (auto symb_expr = dynamic_cast<ir::SymbolExpression*>(input.get()))
    {
        if (destination.size() == 0) throw std::runtime_error("Can't assign symbol expression to null.");
        auto alloca_src = symb_expr->getValue();
        auto find_result = variable_offsets.find(alloca_src.get());
        if (find_result == variable_offsets.end()) throw std::runtime_error("Did not find assigned offset to alloca instruction.");
        auto& [_, offset] = *find_result;
        out << "SET " << destination << ", " << "[$SP-" << offset << "]" << std::endl;
    }
    else if (auto binop = dynamic_cast<ir::BinaryOpExpression*>(input.get()))
    {
        auto result_destination = get_expr_destination(binop, temporary_variables_mapping, variable_offsets);
        generate_binaryop(std::dynamic_pointer_cast<ir::BinaryOpExpression>(input), result_destination, variable_offsets, temporary_variables_mapping, out);
    }
    else if (auto objattrexp = dynamic_cast<ir::ObjectAttributeExpression*>(input.get()))
    {
        auto result_destination = get_expr_destination(objattrexp, temporary_variables_mapping, variable_offsets);
        auto attr_offset = get_object_attribute_offset(objattrexp->getClass(), objattrexp->getAttribute()->name());
        auto object_alloca = objattrexp->getObject();
        auto object_address = find_offset(object_alloca.get(), variable_offsets);
        if (!object_address) throw std::runtime_error("Attempt to read from object whose stack address was not found: " + object_alloca->name());
        out << "GETWORD $0, [$SP-" << object_address.value() << "], " << attr_offset << std::endl;
        out << "SET " << result_destination << ", $0" << std::endl;
    }
    else if (auto string_cast_expr = dynamic_cast<ir::StringCastExpression*>(input.get()))
    {
        auto operand = string_cast_expr->getOperand();
        std::string operand_location;
        if (operand->is_simple())
        {
            operand_location = "$1";
        }
        else
        {
            operand_location = get_expr_destination(operand.get(), temporary_variables_mapping, variable_offsets);
        }
        generate_expression(operand, operand_location, variable_offsets, temporary_variables_mapping, out);
        auto expr_destination = get_expr_destination(string_cast_expr, temporary_variables_mapping, variable_offsets);
        out << "INT2STRING $0, " << operand_location << "\n";
        out << "SET " << expr_destination << ", $0" << std::endl;
    }
    else if (auto not_expr = dynamic_cast<ir::NotExpression*>(input.get()))
    {
        auto operand = not_expr->getOperand();
        std::string operand_location;
        if (operand->is_simple())
        {
            operand_location = "$1";
        }
        else
        {
            operand_location = get_expr_destination(operand.get(), temporary_variables_mapping, variable_offsets);
        }
        auto expr_destination = get_expr_destination(not_expr, temporary_variables_mapping, variable_offsets);
        generate_expression(operand, operand_location, variable_offsets, temporary_variables_mapping, out);
        out << "NOT $0, " << operand_location << "\n";
        out << "SET " << expr_destination << ", $0" << std::endl;
    }
    else if (auto obj_cast_expr = dynamic_cast<ir::ObjectCastExpression*>(input.get()))
    {
        static std::size_t dyncast_label_id = 0;
        std::string label_name = "dynamic_cast_good_" + std::to_string(dyncast_label_id++);
        auto operand = obj_cast_expr->getOperand();
        std::string operand_location;
        if (operand->is_simple())
        {
            operand_location = "$1";
        }
        else
        {
            operand_location = get_expr_destination(operand.get(), temporary_variables_mapping, variable_offsets);
        }
        auto target_class = obj_cast_expr->getTargetClass();

        generate_expression(operand, operand_location, variable_offsets, temporary_variables_mapping, out);
        if (!operand->is_simple())
            out << "SET $1, " << operand_location << "\n";
        // get the real type of target class, which is stored at object's chunk offset 1
        out << "GETWORD $2, $1, 1\n"; // $2 is the string containing current class name
        out << "EQS $0, $2, \"" << target_class->name() << "\"\n";
        out << "JUMPNZ " << label_name << ", $0\n";
            out << "SETWORD 0, 0, 0\n"; // cause run-time error 28 if the types are not equal
        // otherwise assign the object id to 
        out << "LABEL " << label_name << "\n";
        out << "SET " << destination << ", $1" << std::endl;
    }
    else
    {
        throw std::runtime_error("Generator encountered unsupported expression type: " + input->to_string());
    }
}

void vypcomp::Generator::generate_binaryop(ir::BinaryOpExpression::Ptr input, DestinationName destination, OffsetMap& variable_offsets, TempVarMap& temporary_variables_mapping, OutputStream& out)
{
    // prepare operands
    auto op1 = input->getOp1();
    std::string op1_location;
    if (op1->is_simple())
    {
        op1_location = "$1";
    }
    else
    {
        op1_location = get_expr_destination(op1.get(), temporary_variables_mapping, variable_offsets);
    }

    auto op2 = input->getOp2();
    std::string op2_location;
    if (op2->is_simple())
    {
        op2_location = "$2";
    }
    else
    {
        op2_location = get_expr_destination(op2.get(), temporary_variables_mapping, variable_offsets);
    }
            
    if (!op1->is_simple())
        generate_expression(op1, op1_location, variable_offsets, temporary_variables_mapping, out);
    generate_expression(op2, op2_location, variable_offsets, temporary_variables_mapping, out);
    if (op1->is_simple()) // it's going to be just a simple register set, set it after computing op2, because it can utilize $1 register and overwrite the result
        generate_expression(op1, op1_location, variable_offsets, temporary_variables_mapping, out);
    
    // execute operation
    if (auto addop = dynamic_cast<ir::AddExpression*>(input.get()))
    {

        if (input->type() == ir::Datatype(ir::PrimitiveDatatype::Int))
            out << "ADDI $0, " << op1_location << ", " << op2_location << "\n";
        else if (input->type() == ir::Datatype(ir::PrimitiveDatatype::Float))
            out << "ADDF $0, " << op1_location << ", " << op2_location << "\n";
        else if (input->type() == ir::Datatype(ir::PrimitiveDatatype::String))
        {
            std::for_each(variable_offsets.begin(), variable_offsets.end(), [](auto& ptr_offset_pair) { ptr_offset_pair.second += 3ll;  });
            std::string op1_location_shifted;
            if (op1->is_simple())
            {
                op1_location_shifted = op1_location;
            }
            else
            {
                op1_location_shifted = get_expr_destination(op1.get(), temporary_variables_mapping, variable_offsets);
            }
            std::string op2_location_shifted;
            if (op2->is_simple())
            {
                op2_location_shifted = op2_location;
            }
            else
            {
                op2_location_shifted = get_expr_destination(op2.get(), temporary_variables_mapping, variable_offsets);
            }
            std::for_each(variable_offsets.begin(), variable_offsets.end(), [](auto& ptr_offset_pair) { ptr_offset_pair.second -= 3ll;  });
            // call addStr subroutine with the 2 operands
            out << "ADDI $SP, $SP, 3\n";
            out << "SET [$SP-2], " << op1_location_shifted << "\n";
            out << "SET [$SP-1], " << op2_location_shifted << "\n";
            out << "CALL [$SP], addStr" << std::endl;
        }
        else
            throw std::runtime_error("Unexpected operand in + operation: "s + input->to_string());
    }
    else if (auto minop = dynamic_cast<ir::SubtractExpression*>(input.get()))
    {
        if (input->type() == ir::Datatype(ir::PrimitiveDatatype::Int))
        {
            out << "SUBI $0, " << op1_location << ", " << op2_location << "\n";
        }
        else if (input->type() == ir::Datatype(ir::PrimitiveDatatype::Float))
            out << "SUBF $0, " << op1_location << ", " << op2_location << "\n";
        else
        {
            throw std::runtime_error("Unexpected operand in - opertaion: "s + input->to_string());
        }
    }
    else if (auto mulop = dynamic_cast<ir::MultiplyExpression*>(input.get()))
    {
        if (input->type() == ir::Datatype(ir::PrimitiveDatatype::Int))
        {
            out << "MULI $0, " << op1_location << ", " << op2_location << "\n";
        }
        else if (input->type() == ir::Datatype(ir::PrimitiveDatatype::Float))
            out << "MULF $0, " << op1_location << ", " << op2_location << "\n";
        else
        {
            throw std::runtime_error("Unexpected operand in * opertaion: "s + input->to_string());
        }
    }
    else if (auto divop = dynamic_cast<ir::DivideExpression*>(input.get()))
    {
        if (input->type() == ir::Datatype(ir::PrimitiveDatatype::Int))
        {
            out << "DIVI $0, " << op1_location << ", " << op2_location << "\n";
        }
        else if (input->type() == ir::Datatype(ir::PrimitiveDatatype::Float))
            out << "DIVF $0, " << op1_location << ", " << op2_location << "\n";
        else
        {
            throw std::runtime_error("Unexpected operand in / opertaion: "s + input->to_string());
        }
    }
    else if (auto andop = dynamic_cast<ir::AndExpression*>(input.get()))
    {
        out << "AND $0, " << op1_location << ", " << op2_location << "\n";
    }
    else if (auto orop = dynamic_cast<ir::OrExpression*>(input.get()))
    {
        out << "OR $0, " << op1_location << ", " << op2_location << "\n";
    }
    else if (auto eqop = dynamic_cast<ir::ComparisonExpression*>(input.get()))
    {
        switch (eqop->getOperation())
        {
        case ir::ComparisonExpression::EQUALS:
            if ((op1->type() == ir::Datatype(ir::PrimitiveDatatype::Int) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Int)) || (op1->type().is<ir::Datatype::ClassName>() && op2->type().is<ir::Datatype::ClassName>()))
                // for object type just compare the chunk ids as ints
                out << "EQI $0, " << op1_location << ", " << op2_location << "\n";
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::Float) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Float))
                out << "EQF $0, " << op1_location << ", " << op2_location << "\n";
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::String) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::String))
                out << "EQS $0, " << op1_location << ", " << op2_location << "\n";
            else
            {
                throw std::runtime_error("Unexpected operand type in == opertaion: "s + input->to_string());
            }
            break;
        case ir::ComparisonExpression::NOTEQUALS:
            // EQUALS and NOT the result
            if ((op1->type() == ir::Datatype(ir::PrimitiveDatatype::Int) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Int)) || (op1->type().is<ir::Datatype::ClassName>() && op2->type().is<ir::Datatype::ClassName>()))
                // for object type just compare the chunk ids as ints
                out << "EQI $0, " << op1_location << ", " << op2_location << "\n";
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::Float) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Float))
                out << "EQF $0, " << op1_location << ", " << op2_location << "\n";
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::String) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::String))
                out << "EQS $0, " << op1_location << ", " << op2_location << "\n";
            else
            {
                throw std::runtime_error("Unexpected operand type in == opertaion: "s + input->to_string());
            }
            out << "NOT $0, $0\n";
            break;
        case ir::ComparisonExpression::LESS:
            if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::Int) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Int))
            {
                out << "LTI $0, " << op1_location << ", " << op2_location << "\n";
            }
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::Float) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Float))
            {
                out << "LTF $0, " << op1_location << ", " << op2_location << "\n";
            }
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::String) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::String))
            {
                out << "LTS $0, " << op1_location << ", " << op2_location << "\n";
            }
            else
            {
                throw std::runtime_error("Unexpected operand type in < operation: "s + input->to_string());
            }
            break;
        case ir::ComparisonExpression::GREATER:
            if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::Int) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Int))
            {
                out << "GTI $0, " << op1_location << ", " << op2_location << "\n";
            }
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::Float) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Float))
            {
                out << "GTF $0, " << op1_location << ", " << op2_location << "\n";
            }
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::String) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::String))
            {
                out << "GTS $0, " << op1_location << ", " << op2_location << "\n";
            }
            else
            {
                throw std::runtime_error("Unexpected operand type in > operation: "s + input->to_string());
            }
            break;
        case ir::ComparisonExpression::LEQ:
            // for <= do !(>)
            if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::Int) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Int))
            {
                out << "GTI $0, " << op1_location << ", " << op2_location << "\n";
            }
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::Float) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Float))
            {
                out << "GTF $0, " << op1_location << ", " << op2_location << "\n";
            }
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::String) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::String))
            {
                out << "GTS $0, " << op1_location << ", " << op2_location << "\n";
            }
            else
            {
                throw std::runtime_error("Unexpected operand type in <= operation: "s + input->to_string());
            }
            out << "NOT $0, $0\n";
            break;
        case ir::ComparisonExpression::GEQ:
            // for >= do !(<)
            if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::Int) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Int))
            {
                out << "LTI $0, " << op1_location << ", " << op2_location << "\n";
            }
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::Float) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::Float))
            {
                out << "LTF $0, " << op1_location << ", " << op2_location << "\n";
            }
            else if (op1->type() == ir::Datatype(ir::PrimitiveDatatype::String) && op2->type() == ir::Datatype(ir::PrimitiveDatatype::String))
            {
                out << "LTS $0, " << op1_location << ", " << op2_location << "\n";
            }
            else
            {
                throw std::runtime_error("Unexpected operand type in >= operation: "s + input->to_string());
            }
            out << "NOT $0, $0\n";
            break;
        default:
            throw std::runtime_error("Unexpected comparison type in comparison: "s + input->to_string());
        }
    }
    else
    {
        throw std::runtime_error("Generator encountered unsupported expression type: " + input->to_string());
    }
    out << "SET " << destination << ", $0" << std::endl;
}

bool vypcomp::Generator::is_alloca(vypcomp::ir::Instruction::Ptr instr) const
{
    return dynamic_cast<ir::AllocaInstruction*>(instr.get()) != nullptr;
}

bool vypcomp::Generator::is_return(vypcomp::ir::Instruction::Ptr instr) const
{
    return dynamic_cast<ir::Return*>(instr.get()) != nullptr;
}

vypcomp::Generator::AllocaVector vypcomp::Generator::get_alloca_instructions(vypcomp::ir::Instruction::Ptr first, TempVarMap& exp_temporary_mapping)
{
    std::vector<ir::AllocaInstruction::Ptr> result;

    for (auto current = first; current != nullptr; current = current->next())
    {
        if (auto alloca_instr = std::dynamic_pointer_cast<ir::AllocaInstruction>(current))
        {
            result.push_back(alloca_instr);
        }
        else if (auto branch_instr = std::dynamic_pointer_cast<ir::BranchInstruction>(current))
        {
            auto allocas_cond = get_temporary_allocas(branch_instr->getExpr(), exp_temporary_mapping);
            auto allocas_if = get_alloca_instructions(branch_instr->getIf()->first(), exp_temporary_mapping);
            auto allocas_else = get_alloca_instructions(branch_instr->getElse()->first(), exp_temporary_mapping);
            result.insert(result.end(), allocas_cond.begin(), allocas_cond.end());
            result.insert(result.end(), allocas_if.begin(), allocas_if.end());
            result.insert(result.end(), allocas_else.begin(), allocas_else.end());
        }
        else if (auto loop_instr = std::dynamic_pointer_cast<ir::LoopInstruction>(current))
        {
            auto allocas_cond = get_temporary_allocas(loop_instr->getExpr(), exp_temporary_mapping);
            auto allocas_body = get_alloca_instructions(loop_instr->getBody()->first(), exp_temporary_mapping);
            result.insert(result.end(), allocas_cond.begin(), allocas_cond.end());
            result.insert(result.end(), allocas_body.begin(), allocas_body.end());
        }
        else if (auto assignment = std::dynamic_pointer_cast<ir::Assignment>(current))
        {
            // if assignment, analyze if expressions needs temporaries
            auto expr = assignment->getExpr();
            auto allocas = get_temporary_allocas(expr, exp_temporary_mapping);
            result.insert(result.end(), allocas.begin(), allocas.end());
        }
        else if (auto assignment = std::dynamic_pointer_cast<ir::ObjectAssignment>(current))
        {
            auto target = assignment->getTarget();
            auto expr = assignment->getExpr();
            auto expr_allocas = get_temporary_allocas(expr, exp_temporary_mapping);
            result.insert(result.end(), expr_allocas.begin(), expr_allocas.end());
        }
        else if (auto ret_instr = std::dynamic_pointer_cast<ir::Return>(current))
        {
            if (!ret_instr->isVoid())
            {
                // analyze if return expression needs temporaries
                auto expr = ret_instr->getExpr();
                auto allocas = get_temporary_allocas(expr, exp_temporary_mapping);
                result.insert(result.end(), allocas.begin(), allocas.end());
            }
        }
    }
    return result;
}

std::vector<ir::AllocaInstruction::Ptr> vypcomp::Generator::get_temporary_allocas(ir::Expression::ValueType expr, TempVarMap& exp_temporary_mapping)
{
    std::vector<ir::AllocaInstruction::Ptr> result;
    if (!expr->is_simple())
    {
        auto required_temps = get_required_temporaries(expr, exp_temporary_mapping);
        result.insert(result.end(), required_temps.begin(), required_temps.end());
    }
    return result;
}

std::vector<ir::AllocaInstruction::Ptr> vypcomp::Generator::get_required_temporaries(ir::Expression::ValueType expr, TempVarMap& exp_temporary_mapping)
{
    std::vector<ir::AllocaInstruction::Ptr> result;
    // very conservative approach to generating temporaries, possible improvement would reuse old temporaries and free registers
    // for now, every binary expression result is stored in a new stack variable
    if (expr->is_simple()) 
        return {};
    else if (auto func_expr = dynamic_cast<ir::FunctionExpression*>(expr.get()))
    {
        auto arg_expressions = func_expr->getArgs();
        for (auto& arg_expression : arg_expressions)
        {
            auto temps = get_required_temporaries(arg_expression, exp_temporary_mapping);
            result.insert(result.end(), temps.begin(), temps.end());
        }
        auto func_result_temp = std::make_shared<ir::AllocaInstruction>(std::make_pair(func_expr->type(), func_expr->to_string()));
        exp_temporary_mapping[func_expr] = func_result_temp.get();
        result.push_back(func_result_temp);
    }
    else if (auto binop_exp = dynamic_cast<ir::BinaryOpExpression*>(expr.get()))
    {
        auto exp_str = binop_exp->to_string();
        auto op1 = binop_exp->getOp1();
        auto op2 = binop_exp->getOp2();
        auto op1_temps = get_required_temporaries(op1, exp_temporary_mapping);
        result.insert(result.end(), op1_temps.begin(), op1_temps.end());
        auto op2_temps = get_required_temporaries(op2, exp_temporary_mapping);
        result.insert(result.end(), op2_temps.begin(), op2_temps.end());

        auto new_temporary = std::make_shared<ir::AllocaInstruction>(std::make_pair(binop_exp->type(), binop_exp->to_string()));
        exp_temporary_mapping[binop_exp] = new_temporary.get();
        result.push_back(new_temporary);
    }
    else if (auto not_exp = dynamic_cast<ir::NotExpression*>(expr.get()))
    {
        auto operand_temporaries = get_required_temporaries(not_exp->getOperand(), exp_temporary_mapping);
        result.insert(result.end(), operand_temporaries.begin(), operand_temporaries.end());
        auto new_temporary = std::make_shared<ir::AllocaInstruction>(std::make_pair(not_exp->type(), not_exp->to_string()));
        exp_temporary_mapping[not_exp] = new_temporary.get();
        result.push_back(new_temporary);
    }
    else if (auto object_access_attr = dynamic_cast<ir::ObjectAttributeExpression*>(expr.get()))
    {
        auto new_temporary = std::make_shared<ir::AllocaInstruction>(std::make_pair(object_access_attr->type(), object_access_attr->to_string()));
        exp_temporary_mapping[object_access_attr] = new_temporary.get();
        result.push_back(new_temporary);
    }
    else if (auto string_cast_expr = dynamic_cast<ir::StringCastExpression*>(expr.get()))
    {
        auto operand = string_cast_expr->getOperand();
        auto op_temps = get_required_temporaries(operand, exp_temporary_mapping);
        result.insert(result.end(), op_temps.begin(), op_temps.end());
        auto new_temporary = std::make_shared<ir::AllocaInstruction>(std::make_pair(ir::Datatype(ir::PrimitiveDatatype::String), string_cast_expr->to_string()));
        exp_temporary_mapping[string_cast_expr] = new_temporary.get();
        result.push_back(new_temporary);
    }
    else if (auto obj_cast_expr = dynamic_cast<ir::ObjectCastExpression*>(expr.get()))
    {
        auto operand = obj_cast_expr->getOperand();
        auto op_temps = get_required_temporaries(operand, exp_temporary_mapping);
        result.insert(result.end(), op_temps.begin(), op_temps.end());
    }
    else
    {
        throw std::runtime_error("Unexpected expression type in get_required_temporaries. expr is "s + expr->to_string());
    }
    return result;
}

std::optional<std::size_t> vypcomp::Generator::find_offset(AllocaRawPtr alloca_ptr, OffsetMap& variable_offsets) const
{
    if (auto search_result = variable_offsets.find(alloca_ptr); search_result != variable_offsets.end())
    {
        return search_result->second;
    }
    return std::nullopt;
}

std::optional<vypcomp::Generator::AllocaRawPtr> vypcomp::Generator::find_expr_destination(ExprRawPtr expr, TempVarMap& temporary_variables_mapping) const
{
    if (auto mapping_result = temporary_variables_mapping.find(expr); mapping_result != temporary_variables_mapping.end())
    {
        return mapping_result->second;
    }
    return std::nullopt;
}

// for non-simple expressions only, gets the stack position for given expression to store result into
vypcomp::Generator::DestinationName vypcomp::Generator::get_expr_destination(ExprRawPtr expr, TempVarMap& temporary_variables_mapping, OffsetMap& variable_offsets) const
{
    auto exp_destination = find_expr_destination(expr, temporary_variables_mapping);
    if (!exp_destination) throw std::runtime_error("Expression destination was not a temporary variable: "s + expr->to_string());
    auto destination_offset = find_offset(exp_destination.value(), variable_offsets);
    if (!destination_offset) throw std::runtime_error("Expression destination's offset not found: "s + expr->to_string());
    return "[$SP-"s + std::to_string(destination_offset.value()) + "]"s;
}

void vypcomp::Generator::generate_builtin_functions(OutputStream& out)
{
    // print is broken up into intrinsic WRITEI etc. calls on call site
    // readInt
    out << "LABEL " << VYPLANG_PREFIX << "readInt\n";
    out << "READI $0\n";
    out << "SET $1, [$SP]\n";
    out << "SUBI $SP, $SP, 1\n"; // length has no parameters
    out << "RETURN $1\n" << std::endl;

    // readFloat
    out << "LABEL " << VYPLANG_PREFIX << "readFloat\n";
    out << "READF $0\n";
    out << "SET $1, [$SP]\n";
    out << "SUBI $SP, $SP, 1\n"; // length has no parameters
    out << "RETURN $1\n" << std::endl;

    // readString
    out << "LABEL " << VYPLANG_PREFIX << "readString\n";
    out << "READS $0\n";
    out << "SET $1, [$SP]\n";
    out << "SUBI $SP, $SP, 1\n"; // length has no parameters
    out << "RETURN $1\n" << std::endl;

    // length
    out << "LABEL " << VYPLANG_PREFIX << "length\n";
    out << "GETSIZE $0, [$SP-1]\n";
    out << "SET $1, [$SP]\n";
    out << "SUBI $SP, $SP, 2\n"; // length has one parameter
    out << "RETURN $1\n" << std::endl;

    // subStr(string s, int i, int n)
    constexpr std::string_view subStr_impl =
R"vc(# [$SP-3] s
# [$SP-2] i
# [$SP-1] n
# [$SP-0] ret_addr
# $1 length(s)
GETSIZE $1, [$SP-3] 
# if length < 0, return s
LTI $0, $1, 0
JUMPZ subStr_s_check_cont, $0
SET $0, [$SP-3]
JUMP subStr_return
LABEL subStr_s_check_cont
# test i
GTI $2, [$SP-2], 0
LTI $3, [$SP-2], $1
AND $0, $2, $3
# if 0 < i < length(s)
JUMPNZ subStr_i_check_cont, $0
SET $0, ""
JUMP subStr_return
LABEL subStr_i_check_cont
# test n
LTI $0, [$SP-1], 0
JUMPZ subst_n_check_cont, $0
# if n < 0 return empty string
SET $0, ""
JUMP subStr_return
LABEL subst_n_check_cont
# execute subStr copy
SET $2, 0 # loop counter
CREATE $0, [$SP-1]
LABEL subStr_loop_cond
LTI $3, $2, [$SP-1]
JUMPZ subStr_loop_end, $3
# loop body
ADDI $4, $2, [$SP-2] # offset in src
# if offset in src is too big, get i'th
LTI $5, $4, $1
JUMPZ subStr_overflow_start, $5
GETWORD $5, [$SP-3], $4
JUMP subStr_overflow_end
LABEL subStr_overflow_start
GETWORD $5, [$SP-3], [$SP-2] # get i-th instead
LABEL subStr_overflow_end
SETWORD $0, $2, $5
ADDI $2, $2, 1
JUMP subStr_loop_cond
# loop body end
LABEL subStr_loop_end
LABEL subStr_return
SET $1, [$SP]
SUBI $SP, $SP, 4
RETURN $1)vc";
    out << "LABEL " << VYPLANG_PREFIX << "subStr\n";
    out << subStr_impl << std::endl;

    // addStr
    constexpr std::string_view add_strings = 
R"vc(LABEL addStr
# $0 destination
# $1 op1 string, later loop condition result
# $2 op2 string
# $3 iterator over op2
# $4 offset in destination chunk
# $5 size of destination chunk, later value copied
# $6 size op1 
# $7 size op2
SET $1, [$SP-2]
SET $2, [$SP-1]
COPY $0, $1
GETSIZE $6, $1
GETSIZE $7, $2
ADDI $5, $6, $7
RESIZE $0, $5

SET $3, 0
LABEL strcpy_loop
LTI $1, $3, $7
JUMPZ strcpy_end, $1
ADDI $4, $6, $3 # get offset in the destination chunk
GETWORD $5, $2, $3
SETWORD $0, $4, $5
ADDI $3, $3, 1
JUMP strcpy_loop
LABEL strcpy_end
SET $1, [$SP]
SUBI $SP, $SP, 3
RETURN $1)vc";
    out << add_strings << std::endl;
}

bool vypcomp::Generator::is_builtin_func(std::string func_name) const
{
    if (
        func_name == "print" ||
        func_name == "readInt" ||
        func_name == "readFloat" ||
        func_name == "readString" ||
        func_name == "length" ||
        func_name == "subStr"
    ) {
        return true;
    }
    return false;
}

std::size_t vypcomp::Generator::get_object_attribute_offset(vypcomp::ir::Class::Ptr class_ptr, const std::string& attribute_name)
{
    if (!class_ptr) return 0;
    auto parent_ptr = class_ptr->getBase();
    std::size_t parent_offset = get_object_attribute_offset(parent_ptr, attribute_name);
    if (parent_offset != 0)
    {
        return parent_offset;
    }
    else
    {
        // attribute is part of this class
        auto parent_offset = parent_ptr ? get_object_size(parent_ptr) : 0;
        std::size_t attr_offset = parent_offset;
        // now search for the attribute in this class
        for (auto& atrr_list : { class_ptr->publicAttributes(), class_ptr->protectedAttributes(), class_ptr->privateAttributes() })
        {
            for (auto& attr : atrr_list)
            {
                if (attr->name() == attribute_name) return attr_offset;
                attr_offset += 1;
            }
        }
        return 0;
    }
}
